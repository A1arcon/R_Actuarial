table(c(Ydata$Y),c(Ydata$Yf))
libray(pROC)
install.packages("pROC")
table(c(Ydata$Y),c(Ydata$Yf))
library(pROC)
table(c(Ydata$Y),c(Ydata$Yf))
Ydata$Y
Ydata$Y
roc(Ydata$Y, # obvservadas
Ydata$Yf,# Pronosticas
plot=TRUE,auc.polygon=TRUE,grid=TRUE)
roc(Ydata$Y, # obvservadas
Ydata$Yf,# Pronosticas
plot=TRUE,auc.polygon=TRUE,grid=TRUE,print.auc=TRUE)
table(c(Ydata$Y),c(Ydata$Yf))
length(Y)
rbinom(length(Ydata$Y),0.5)
rbinom(length(Ydata$Y),1,0.5)
roc(Ydata$Y, # obvservadas
rbinom(length(Ydata$Y),1,0.5),# Pronosticas
plot=TRUE,auc.polygon=TRUE,grid=TRUE,print.auc=TRUE)
rbinom(length(Ydata$Y),1,0.5)
# Esto es lo "mejor" que puede pasar
roc(Ydata$Y, # obvservadas
Ydata$Yf,# Pronosticas
plot=TRUE,auc.polygon=TRUE,grid=TRUE,print.auc=TRUE)
# Esto es lo peor que puede pasar
roc(Ydata$Y, # obvservadas
rbinom(length(Ydata$Y),1,0.5),# Pronosticas
plot=TRUE,auc.polygon=TRUE,grid=TRUE,print.auc=TRUE)
# Esto es lo "mejor" que puede pasar
roc(Ydata$Y, # obvservadas
Ydata$Yf,# Pronosticas
plot=TRUE,auc.polygon=TRUE,grid=TRUE,print.auc=TRUE)
# Esto es lo peor que puede pasar
roc(Ydata$Y, # obvservadas
rbinom(length(Ydata$Y),1,0.5),# Pronosticas
plot=TRUE,auc.polygon=TRUE,grid=TRUE,print.auc=TRUE)
# Esto es lo peor que puede pasar
roc(Ydata$Y, # obvservadas
1-Ydata$Yf,1,0.5),# Pronosticas
plot=TRUE,auc.polygon=TRUE,grid=TRUE,print.auc=TRUE)
# Esto es lo peor que puede pasar
roc(Ydata$Y, # obvservadas
(1-Ydata$Yf),1,0.5),# Pronosticas
plot=TRUE,auc.polygon=TRUE,grid=TRUE,print.auc=TRUE)
# Esto es lo peor que puede pasar
roc(Ydata$Y, # obvservadas
(1-Ydata$Yf),# Pronosticas
plot=TRUE,auc.polygon=TRUE,grid=TRUE,print.auc=TRUE)
(1-Ydata$Yf)
table(c(Ydata$Y),c(1-Ydata$Yf))
?roc
table(c(Ydata$Y),c(Ydata$Yf))
EY
EY
Y <- mapply(FUN = rbinom, prob = EY, MoreArgs = list(n=1))
Y <- mapply(FUN = rbinom, prob = EY, MoreArgs = list(n=1,size=1))
Y
Y[10]
EY[10]
plot(Y~X)
plot(Y~X)
boxplot(Y~X)
boxplot(X~Y)
fit <- glm(Y~X,family = binomial())
fit$coefficients
c(a,b)
plot(Y~X)
curve(ginv(a+b*x),col="red",lwd=2)
plot(Y~X)
curve(ginv(a+b*x),col="red",lwd=2,add=TRUE)
abline(h=0.5,col="blue",lwd=2)
# Tabla de contingencia cruzada
Ydata <- data.frame(EY,Y,
EYf=fit$fitted.values,Yf = round(fit$fitted.values))
table(c(Ydata$Y),c(Ydata$Yf))
library(rgl)
library(magrittr)
setwd("~/Actuaría/Docencia/AMAT/R Intermedio/_Datos e Instalaciones/Perspectiva")
dat <- read.table("Perspectiva.txt") %>% as.matrix()
#View(dat)
plot(dat[,1],dat[,3])
plot3d(dat[,1],dat[,2],dat[,3])
# PCA (Hay dos opciones populares)
(PCA <- princomp(dat))
(PCA_2 <- prcomp(dat))
summary(PCA)
summary(PCA_2)
PCA$sdev
PCA_2$sdev
dim(PCA$scores)
dim(PCA_2$x)
PCA$loadings[]
PCA_2$rotation
# Tomamos los dos componentes más grandes.
plot(PCA$scores[,1:2], main = "PCA 2")
# Tomando todos los componentes, no vemos algo nuevo.
PCA_3 <- PCA$scores %>% as.data.frame()
plot3d(PCA_3[,1],PCA_3[,2],PCA_3[,3])
hc.complete <- hclust(dist(PCA_3), method = "complete")
# Se grafican
plot(hc.complete)
# Ponemos el corte a la altura requerida
rect.hclust(hc.complete, k = 2, border = 2:4)
# Hacemos grupos y graficamos
PCA_3$Grupo <- cutree(hc.complete,k = 2) %>% as.vector() %>% as.factor()
plot3d(PCA_3[,1],PCA_3[,2],PCA_3[,3],col = PCA_3$Grupo)
library(rgl)
library(dplyr)
setwd("~/Actuaría/Docencia/AMAT/R Intermedio/_Datos e Instalaciones/Perspectiva")
dat <- read.table("Perspectiva.txt") %>% as.matrix()
# Observemos los datos
View(dat)
plot(dat[,1],dat[,2])
plot(dat[,1],dat[,3])
plot(dat[,2],dat[,3])
plot3d(dat[,1],dat[,2],dat[,3])
plot3d(dat[,1],dat[,2],dat[,3])
plot3d(dat[,1],dat[,2],dat[,3])
plot(dat[,1],dat[,2])
plot(dat[,1],dat[,3])
plot(dat[,2],dat[,3])
cov(dat)
eigen(cov(dat))
eiganval <- eigen(cov(dat))$values
eiganval
# Porcentaje de volatilidad explicada
eiganval/sum(eiganval)
eiganvec <- eigen(cov(dat))$vectors
# Obtenemos los eigan valores
eigenval <- eigen(cov(dat))$values
# Porcentaje de volatilidad explicada
eigenval/sum(eiganval)
# Obtenemos los eigen vectores
eigenvec <- eigen(cov(dat))$vectors
eigenvec
eigenval/sum(eiganval)
plot3d(dat[,1],dat[,2],dat[,3])
# Multiplicando matrices
dim(dat)
dim(eigenvec)
eigenvec[,1:2]
PCA <- dat %*% eigenvec[,1:2]
dim(PCA)
plot(PCA)
?princomp()
?prcomp()
dat %*% eigenvec[,1:2]
eigenvec
1:10 %in% c(1,16,11,10)
PCA <- princomp(dat)
PCA_2 <- prncomp(dat)
PCA_2 <- prcomp(dat)
summary(PCA)
summary(PCA_2)
eigenval
eigenval %>% sqrt()
# Esta es la desvest
sqrt(eigenval)
summary(PCA)
# Esta es la desvest
sqrt(eigenval)
# Porcentaje de volatilidad explicada
eigenval/sum(eiganval)
cumsum(eigenval/sum(eiganval))
PCA$call
PCA$scores
PCA$scores == dat %*% eigenvec
dat %*% eigenvec
plot(PCA$scores[,1:2],main="PCA 1 y 2")
eigenval/sum(eiganval)
summary(PCA)
0.1687474 + 0.1589830
plot(PCA$scores[,2:3],main="PCA 2 y 3")
0.6722697 + 0.1589830
plot(PCA$scores[,1:3],main="PCA 1 y 3")
PCA$scores[,1:3]
plot(PCA$scores[,c(1,3)],main="PCA 1 y 3")
eigenval/sum(eiganval)
PCA$scores[,1]
hist(PCA$scores[,1])
MASS::truehist(PCA$scores[,1])
plot(PCA$scores[,1],5)
plot(PCA$scores[,1],rep(5,nrow(PCA$scores)))
plot(PCA$scores[,1],rep(5,nrow(PCA$scores)),pch=".")
plot(PCA$scores[,1:2],main="PCA 1 y 2")
dist(PCA$scores)
cluster <- hclust(dist(PCA$scores))
cluster
plot(cluster)
distancia <- dist(PCA$scores)
dim(distancia)
distancia
class(distancia)
mode(distancia)
View(distancia)
distancia[1]
distancia[2]
distancia %>% as.matrix()
distancia %>% as.matrix() %>% dim()
distancia %>% as.matrix() %>% View()
rect.hclust(cluster, # cluster que estoy trabajando
k=2     # Cuántos clusters/grupos quieres
)
rect.hclust(cluster, # cluster que estoy trabajando
k=2,     # Cuántos clusters/grupos quieres
border=c("blue","red"))
# Cortar tres grupos
plot(cluster)
rect.hclust(cluster, # cluster que estoy trabajando
k=3,     # Cuántos clusters/grupos quieres
border=c("blue","red","pink"))
PC <- PCA$scores
PC <- PCA$scores
cutree(cluster,k=2)
PC$Grupo <- cutree(cluster,k=2)
cutree(cluster,k=2) %>% class()
cutree(cluster,k=2) %>% mode()
PC$Grupo <- cutree(cluster,k=2) %>% as.vector() %>% as.factor()
cutree(cluster,k=2)
View(PC)
PCA$scores
# Estoy guardando los scores
PC <- PCA$scores
PC$Grupo <- cutree(cluster,k=2) %>% as.vector() %>% as.factor()
View(PC)
PC <- PCA$scores %>% as.data.frame()
PC$Grupo <- cutree(cluster,k=2) %>% as.vector() %>% as.factor()
View(PC)
plot3d(PC$Comp.1,PC$Comp.2,PC$Comp.3,col=PC$Grupo)
PC <- PCA$scores %>% as.data.frame()
PC$Grupo <- cutree(cluster,k=3) %>% as.vector() %>% as.factor()
#View(PC)
plot3d(PC$Comp.1,PC$Comp.2,PC$Comp.3,col=PC$Grupo)
PC <- PCA$scores %>% as.data.frame()
PC$Grupo <- cutree(cluster,k=4) %>% as.vector() %>% as.factor()
#View(PC)
plot3d(PC$Comp.1,PC$Comp.2,PC$Comp.3,col=PC$Grupo)
?dist
distancia <- dist(PCA$scores,method = "maximum")
#distancia %>% as.matrix() %>% View()
cluster <- hclust(distancia)
# Graficamos un dendograma
# Cortando dos grupos
plot(cluster)
rect.hclust(cluster, # cluster que estoy trabajando
k=2,     # Cuántos clusters/grupos quieres
border=c("blue","red"))
# Cortar tres grupos
plot(cluster)
rect.hclust(cluster, # cluster que estoy trabajando
k=3,     # Cuántos clusters/grupos quieres
border=c("blue","red","pink"))
# Estoy guardando los scores
PC <- PCA$scores %>% as.data.frame()
PC$Grupo <- cutree(cluster,k=4) %>% as.vector() %>% as.factor()
#View(PC)
plot3d(PC$Comp.1,PC$Comp.2,PC$Comp.3,col=PC$Grupo)
PC <- PCA$scores %>% as.data.frame()
PC$Grupo <- cutree(cluster,k=2) %>% as.vector() %>% as.factor()
#View(PC)
plot3d(PC$Comp.1,PC$Comp.2,PC$Comp.3,col=PC$Grupo)
dat
datos <- dat
datos$Grupo <- PC$Grupo
# Un primer reporte final que pueden mostrar
datos <- dat %>% as.data.frame()
datos$Grupo <- PC$Grupo
datos
plot(datos[,1:2],col=datos$Grupo)
library(tuneR)
install.packages("tuneR")
library(tuneR)
setwd("~/Actuaría/Docencia/AMAT/R Intermedio/_Datos e Instalaciones/Music")
setwd("~/Actuaría/Docencia/AMAT/R Intermedio/_Datos e Instalaciones/Music")
getwd()
file.path(getwd(),"Rock/Let It Be.mp3")
Periodo <- file.path(getwd(),"Rock/Let It Be.mp3") %>%
readMP3() %>%
extractWave(from=0,to=60,xunit = "time") %>%
mono(which = "left") %>%
periodogram()
class(Periodo)
mode(Periodo)
Periodo@freq
length(Periodo@freq)
Frecuencia <- Periodo@freq[1:50000]
Densidad_Espectral <- Periodo@spec[[1]][1:50000]
plot(x = Frecuencia,y = Densidad_Espectral,type="h",main="Let It Be - Beatles")
sum(Periodo@spec[[1]])
sum(dbinom(1:10,size = 10,prob = 0.5))
sum(dbinom(0:10,size = 10,prob = 0.5))
# Binomial
sum(dbinom(0:10,size = 10,prob = 0.5))
# Espectral
sum(Periodo@spec[[1]])
Soporte <- Periodo@freq
# Binomial
soporte <- 0:10
# Espectral
Soporte <- Periodo@freq
Densidad <- Periodo@spec[[1]]
Densidad
# Binomial
soporte <- 0:10
densidad <- dbinom(0:10,size = 10,prob = 0.5)
# Espectral
Soporte <- Periodo@freq
Densidad <- Periodo@spec[[1]]
mean <- soporte*densidad
mean
mean <- sum(soporte*densidad)
mean
Lmean <- sum(Soporte*Densidad)
Lmean
var <- sum((soporte-mean)^2*densidad)
var
Lvar <- sum((Soporte-Lmean)^2*Densidad)
Lvar
soporte[which.max(densidad)]
which.max(densidad)
soporte[which.max(densidad)]
max <- soporte[which.max(densidad)]
max
# Espectral
LMax <- Soporte[which.max(Densidad)]
LMax
soporte[densidad>=0.5][1]
densidad>=0.5
soporte[cumsum(densidad)>=0.5][1]
qbinom(0.5,10,0.5)
LMed <- Soporte[cumsum(Densidad)>=0.5][1]
LMed
Periodo@energy
datos <- data.frame()
datos
list.files()
Carpeta="Banda"
Carpeta
getwd() %>% file.path(Carpeta)
getwd() %>% file.path(Carpeta) %>% list.files()
Song="Adiós Amor.mp3"
file.path(getwd(), paste0(Carpeta,"/",Song))
Carpeta
Carpeta
# Leemos el periodo de cada canción:
Periodo <- file.path(getwd(), paste0(Carpeta,"/",Song)) %>%   # Pasamos el directorio.
readMP3() %>%                                # Leemos el tipo de archivo.
extractWave(from=0, to=60, xunit="time") %>% # Extraemos una parte.
mono(which = "left") %>%                     # Tomamos el canal izquierdo.
periodogram()                                # Hacemos el Periodograma.
# Vamos a guardar el soporte (frecuencia) y la densidad en otros objetos
Soporte  <- Periodo@freq
Densidad <- Periodo@spec[[1]]
data.frame(
Género=Carpeta,
Canción=Song, #Quizás podríamos simplificar con expresiones regulares.
# Promedio de las frecuencias del canal izquierdo.
LMean= sum(Soporte*Densidad),
# Varianza de las frecuencias del canal izquierdo.
LVar = sum(((Soporte-sum(Soporte*Densidad))^2)*Densidad),
# Máximo de las frecuencias del canal izquierdo.
LMax = Soporte[which.max(Densidad)],
# Mediana de las frecuencias del canal izquierdo.
LMed = Soporte[which(cumsum(Densidad)>=0.5)[1]],
# Indicador de la fuerza o amplitud del sonido.
LEne = Periodo@energy,
# Rango intercuantílico de las frecuencias del canal izquierdo.
LRan = Soporte[which(cumsum(Densidad)>=0.75)[1]] -
Soporte[which(cumsum(Densidad)>=0.25)[1]]
)
aux <- data.frame(
Género=Carpeta,
Canción=Song, #Quizás podríamos simplificar con expresiones regulares.
# Promedio de las frecuencias del canal izquierdo.
LMean= sum(Soporte*Densidad),
# Varianza de las frecuencias del canal izquierdo.
LVar = sum(((Soporte-sum(Soporte*Densidad))^2)*Densidad),
# Máximo de las frecuencias del canal izquierdo.
LMax = Soporte[which.max(Densidad)],
# Mediana de las frecuencias del canal izquierdo.
LMed = Soporte[which(cumsum(Densidad)>=0.5)[1]],
# Indicador de la fuerza o amplitud del sonido.
LEne = Periodo@energy,
# Rango intercuantílico de las frecuencias del canal izquierdo.
LRan = Soporte[which(cumsum(Densidad)>=0.75)[1]] -
Soporte[which(cumsum(Densidad)>=0.25)[1]]
)
datos<-rbind(datos,aux)
datos
datos <- data.frame()
# En cada carpeta:
for(Carpeta in list.files()){
# Aquí vamos a estar guardando la información:
# Ve a cada canción y calcula la estadística necesaria:
for(Song in getwd() %>% file.path(Carpeta) %>% list.files()){
# Leemos el periodo de cada canción:
Periodo <- file.path(getwd(), paste0(Carpeta,"/",Song)) %>%   # Pasamos el directorio.
readMP3() %>%                                # Leemos el tipo de archivo.
extractWave(from=0, to=60, xunit="time") %>% # Extraemos una parte.
mono(which = "left") %>%                     # Tomamos el canal izquierdo.
periodogram()                                # Hacemos el Periodograma.
# Vamos a guardar el soporte (frecuencia) y la densidad en otros objetos
Soporte  <- Periodo@freq
Densidad <- Periodo@spec[[1]]
# Obtenemos la estadística necesaria:
aux <- data.frame(
Género=Carpeta,
Canción=Song, #Quizás podríamos simplificar con expresiones regulares.
# Promedio de las frecuencias del canal izquierdo.
LMean= sum(Soporte*Densidad),
# Varianza de las frecuencias del canal izquierdo.
LVar = sum(((Soporte-sum(Soporte*Densidad))^2)*Densidad),
# Máximo de las frecuencias del canal izquierdo.
LMax = Soporte[which.max(Densidad)],
# Mediana de las frecuencias del canal izquierdo.
LMed = Soporte[which(cumsum(Densidad)>=0.5)[1]],
# Indicador de la fuerza o amplitud del sonido.
LEne = Periodo@energy,
# Rango intercuantílico de las frecuencias del canal izquierdo.
LRan = Soporte[which(cumsum(Densidad)>=0.75)[1]] -
Soporte[which(cumsum(Densidad)>=0.25)[1]]
)
# Lo guardamos en el dataframe que queremos:
datos<-rbind(datos,aux)
}
}
View(datos)
datos <- data.frame()
# En cada carpeta:
for(Carpeta in list.files()){
# Aquí vamos a estar guardando la información:
# Ve a cada canción y calcula la estadística necesaria:
for(Song in getwd() %>% file.path(Carpeta) %>% list.files()){
# Leemos el periodo de cada canción:
Periodo <- file.path(getwd(), paste0(Carpeta,"/",Song)) %>%   # Pasamos el directorio.
readMP3() %>%                                # Leemos el tipo de archivo.
extractWave(from=0, to=100, xunit="time") %>% # Extraemos una parte.
mono(which = "left") %>%                     # Tomamos el canal izquierdo.
periodogram()                                # Hacemos el Periodograma.
# Vamos a guardar el soporte (frecuencia) y la densidad en otros objetos
Soporte  <- Periodo@freq
Densidad <- Periodo@spec[[1]]
# Obtenemos la estadística necesaria:
aux <- data.frame(
Género=Carpeta,
Canción=Song, #Quizás podríamos simplificar con expresiones regulares.
# Promedio de las frecuencias del canal izquierdo.
LMean= sum(Soporte*Densidad),
# Varianza de las frecuencias del canal izquierdo.
LVar = sum(((Soporte-sum(Soporte*Densidad))^2)*Densidad),
# Máximo de las frecuencias del canal izquierdo.
LMax = Soporte[which.max(Densidad)],
# Mediana de las frecuencias del canal izquierdo.
LMed = Soporte[which(cumsum(Densidad)>=0.5)[1]],
# Indicador de la fuerza o amplitud del sonido.
LEne = Periodo@energy,
# Rango intercuantílico de las frecuencias del canal izquierdo.
LRan = Soporte[which(cumsum(Densidad)>=0.75)[1]] -
Soporte[which(cumsum(Densidad)>=0.25)[1]]
)
# Lo guardamos en el dataframe que queremos:
datos<-rbind(datos,aux)
}
}
View(datos)
warnings()
library(andrews)
library(aplpack)
install.packages(c("andrews", "aplpack"))
library(andrews)
library(aplpack)
datos$Género <- datos$Género %>% as.factor()
datos
plot(1:10)
plot(1:10,col=c("blue","red"))
plot(1:10,col=c("azul","rojo"))
plot(1:10,col=c("azul","rojo") %>% as.factor())
c("azul","rojo") %>% as.factor()
plot(1:10,col=c("blue","red") %>% as.factor())
plot(1:10,col=c("blue","red","green") %>% as.factor())
plot(1:10,col=1:3)
datos %>% select(-Nombre)
datos %>% select(-Canción)
datos %>% select(-Canción) %>%
andrews(clr=1,main="Curvas de Andrews")
datos %>% select(-Canción) %>%
andrews(clr=1,ymax=7,main="Curvas de Andrews")
datos %>% select(-Canción) %>%
andrews(clr=1,ymax=6,main="Curvas de Andrews")
datos %>% select(-Canción) %>%
andrews(clr=1,ymax=5,main="Curvas de Andrews")
datos %>% select(-Canción) %>%
andrews(clr=1,ymax=4,main="Curvas de Andrews")
datos
datos %>% select(-Género,-Canción) %>%
faces(labels = datos$Canción)
View(datos)
?faces
install.packages("Factoshiny")
library(Factoshiny)
datos
datos2 <- datos %>% select(-Canción)
rownames(datos2) <- datos %>% select(Canción)
datos2 <- datos %>% select(-Canción)
rownames(datos2) <- datos %>% select(Canción)
rownames(datos2) <- datos$Canción
datos2 <- datos %>% select(-Canción)
rownames(datos2) <- datos$Canción
View(datos2)
PCAshiny(datos2)

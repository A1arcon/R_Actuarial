fn = f,                   # Función a Optimizar
control=list(fnscale=1),  # Indicamos que queremos minimizar
) -> optim.num
optim.num
# Con esto minimizamos ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
optim(par = c(1,4),             # Valor inicial
fn = f,                   # Función a Optimizar
control=list(fnscale=1),  # Indicamos que queremos minimizar
) -> (optim.num)
optim.num
# minimizar la siguiente funión
fxy <- function(x,y){
sqrt((x-2)^2+(y-3)^2) + 10
}
# Región donde optimizaremos:
a1 = -4 ; b1 = 4
a2 = -4 ; b2 = 4
# Gráfico
{
superficie3d(x.from = a1,x.to = b1,y.from = a2,y.to = b2,
fxy = f,x.lab = "eje x",y.lab = "eje y", z.lab = "eje z",
main = "Gráfico",sombra = TRUE)
}
# Ahora... en este caso hay que cambiar un poco la función
f <- function(v){
x = v[1]
y = v[2]
return(fxy(x,y))
}
# Con esto minimizamos ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
optim(par = c(1,4),             # Valor inicial
fn = f,                   # Función a Optimizar
control=list(fnscale=1),  # Indicamos que queremos minimizar
) -> optim.num
optim.num
# Como se hace en la versión MC
set.seed(6)
optim.MC <- optimize.MC(f = f,n = 1000,lower = a,upper = b,maximizar = FALSE)
optim.MC
# Como se hace en la versión MC
set.seed(6)
optim.MC <- optimize.MC(f = f,n = 1000,
lower = c(a1,a2),
upper = c(b1,b2),
maximizar = FALSE)
optim.MC
optimize.MC <- function(f,n,lower,upper,maximizar=FALSE){
# f := Función a optimizar (recibe vector y arroja un real)
# n := Número de simulaciones a realizar
# lower y upper := vectores, estos comprenden la región de búsqueda.
# maximizar := ¿Se quiere maximizar la función?
mapply(FUN = runif,
# Argumentos a vectorizar
min = lower,
max = upper,
# Argumentos fijos
MoreArgs = list(n = n)
) -> U
# Vamos a aplicar la función a las Uniformes
apply(U,
# Por renglones
MARGIN = 1,
# Aplicamos la función
FUN = f) -> fU
if(maximizar){
indice <- which.max(fU)
return(list(max=U[indice,],
objetivo=fU[indice]))
}else{
indice <- which.min(fU)
return(list(min=U[indice,],
objetivo=fU[indice]))
}
}
# Maximizar la siguiente funión
f <- function(x){
10-(x+5)^2
}
# Región donde optimizaremos:
a = -10 ; b = 10
# Gráfico
{
curve(f,from=a,to=b)
fondo_plot()
curve(f,from=a,to=b,add=TRUE,lwd=2)
abline(h=0,v=0,col="red",lwd=2)
}
# Con esto maximizamos
optim(par = 2,                 # Valor inicial
fn = f,               # Función a Optimizar
control=list(fnscale=-1), # Indicamos que queremos maximizar
# Con esto optimizamos con base en un intervalo
method = "Brent",
# Aquí es donde corre el intervalo
lower = a,
upper = b
)
# Opción 2 (más cómoda)
optimize(
f = f, # Función a optimizar
interval = c(a,b),
maximum = TRUE
) -> optim.num
abline(v = optim.num[[1]],
h = optim.num[[2]],
col="blue",lty=2)
# Como se hace en la versión MC
set.seed(6)
optim.MC <- optimize.MC(f = f,n = 1000,lower = a,upper = b,maximizar = TRUE)
abline(v = optim.MC[[1]],
h = optim.MC[[2]],
col="green",lty=2)
# Maximizar la siguiente funión
f <- function(x){
(cos(50*x) + sin(20*x))^2
}
# Región donde optimizaremos:
a = 0 ; b = 1
# Gráfico
{
curve(f,from=a,to=b)
fondo_plot()
curve(f,from=a,to=b,add=TRUE,lwd=2)
abline(h=0,v=0,col="red",lwd=2)
}
# Con esto maximizamos
optim(par = 2,                  # Valor inicial
fn = f,                   # Función a Optimizar
control=list(fnscale=-1), # Indicamos que queremos maximizar
# Con esto optimizamos con base en un intervalo
method = "Brent",
# Aquí es donde corre el intervalo
lower = a,
upper = b
)
# Opción 2 (más cómoda)
optimize(
f = f, # Función a optimizar
interval = c(a,b),
maximum = TRUE
) -> optim.num
abline(v = optim.num[[1]],
h = optim.num[[2]],
col="blue",lty=2)
# Como se hace en la versión MC
set.seed(6)
optim.MC <- optimize.MC(f = f,n = 1000,lower = a,upper = b,maximizar = TRUE)
abline(v = optim.MC[[1]],
h = optim.MC[[2]],
col="green",lty=2)
set.seed(7)
optim.MC <- optimize.MC(f = f,n = 1000,lower = a,upper = b,maximizar = TRUE)
abline(v = optim.MC[[1]],
h = optim.MC[[2]],
col="green",lty=2)
# Maximizar y minimizar la siguiente funión
f <- function(x){
2*x^3-10*x^2+3*x+10
}
# Región donde optimizaremos:
a = -1 ; b = 4
# Gráfico
{
curve(f,from=a,to=b)
fondo_plot()
curve(f,from=a,to=b,add=TRUE,lwd=2)
abline(h=0,v=0,col="red",lwd=2)
}
# Con esto maximizamos ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
optim(par = 2,                  # Valor inicial
fn = f,                   # Función a Optimizar
control=list(fnscale=-1), # Indicamos que queremos maximizar
# Con esto optimizamos con base en un intervalo
method = "Brent",
# Aquí es donde corre el intervalo
lower = a,
upper = b
)
# Opción 2 (más cómoda)
optimize(
f = f, # Función a optimizar
interval = c(a,b),
maximum = TRUE
) -> optim.num
abline(v = optim.num[[1]],
h = optim.num[[2]],
col="blue",lty=2)
# Como se hace en la versión MC
set.seed(6)
optim.MC <- optimize.MC(f = f,n = 1000,lower = a,upper = b,maximizar = TRUE)
abline(v = optim.MC[[1]],
h = optim.MC[[2]],
col="green",lty=2)
# Con esto minimizamos ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
optim(par = 2,                  # Valor inicial
fn = f,                   # Función a Optimizar
control=list(fnscale=1),  # Indicamos que queremos minimizar
# Con esto optimizamos con base en un intervalo
method = "Brent",
# Aquí es donde corre el intervalo
lower = a,
upper = b
)
# Opción 2 (más cómoda)
optimize(
f = f, # Función a optimizar
interval = c(a,b),
maximum = FALSE
) -> optim.num
abline(v = optim.num[[1]],
h = optim.num[[2]],
col="blue",lty=2)
# Como se hace en la versión MC
set.seed(6)
optim.MC <- optimize.MC(f = f,n = 1000,lower = a,upper = b,maximizar = FALSE)
abline(v = optim.MC[[1]],
h = optim.MC[[2]],
col="green",lty=2)
# minimizar la siguiente funión
fxy <- function(x,y){
sqrt((x-2)^2+(y-3)^2) + 10
}
# Región donde optimizaremos:
a1 = -4 ; b1 = 4
a2 = -4 ; b2 = 4
# Gráfico
{
superficie3d(x.from = a1,x.to = b1,y.from = a2,y.to = b2,
fxy = f,x.lab = "eje x",y.lab = "eje y", z.lab = "eje z",
main = "Gráfico",sombra = TRUE)
}
# minimizar la siguiente funión
fxy <- function(x,y){
sqrt((x-2)^2+(y-3)^2) + 10
}
# Región donde optimizaremos:
a1 = -4 ; b1 = 4
a2 = -4 ; b2 = 4
# Gráfico
{
superficie3d(x.from = a1,x.to = b1,y.from = a2,y.to = b2,
fxy = f,x.lab = "eje x",y.lab = "eje y", z.lab = "eje z",
main = "Gráfico",sombra = TRUE)
}
# Gráfico
{
superficie3d(x.from = a1,x.to = b1,y.from = a2,y.to = b2,
fxy = fxy,x.lab = "eje x",y.lab = "eje y", z.lab = "eje z",
main = "Gráfico",sombra = TRUE)
}
# Ahora... en este caso hay que cambiar un poco la función
f <- function(v){
x = v[1]
y = v[2]
return(fxy(x,y))
}
# Con esto minimizamos ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
optim(par = c(1,4),             # Valor inicial
fn = f,                   # Función a Optimizar
control=list(fnscale=1),  # Indicamos que queremos minimizar
) -> optim.num
optim.num
# Como se hace en la versión MC
set.seed(6)
optim.MC <- optimize.MC(f = f,n = 1000,
lower = c(a1,a2),
upper = c(b1,b2),
maximizar = FALSE)
optim.MC
# Como se hace en la versión MC
set.seed(6)
optim.MC <- optimize.MC(f = f,n = 10000,
lower = c(a1,a2),
upper = c(b1,b2),
maximizar = FALSE)
optim.MC
library(actuar)
alpha=0.75
r=0.1
d=120
u=180
#Definimos la función
aux<-coverage(pdf = dunif,cdf = punif,
limit=u,inflation=r,deductible=d,
coinsurance=alpha,per.loss=TRUE)
aux
#Costo por pérdida
fyL<-function(x){
#Definimos la función
aux<-coverage(pdf = dunif,cdf = punif,
limit=u,inflation=r,deductible=d,
coinsurance=alpha,per.loss=TRUE)
#Caso particular
aux(x,min = 100,max = 200)
}
fyL(45)
4/11
fyL(6)
2/165
F==FALSE
#Costo por pago
fyp<-function(x){
#Definimos la función
aux<-coverage(pdf = dunif,cdf = punif,
limit=u,inflation=r,deductible=d,
coinsurance=alpha,per.loss = F)
#Caso particular
aux(x,min = 100,max = 200)
}
fyp(45)
#Veamos que se da la relación entre
#ellas en diferentes puntos:
aux<-function(x){
#En otro caso:
if(!(0<x &  x <= alpha*(u-d))){
return(0)
}
#Definida donde debe:
fyL(x)/(1-fyL(0))
}
SinActuar<-sapply(X = c(0,10,20,30,40,45,50),
FUN = aux)
conActuar<-sapply(X = c(0,10,20,30,40,45,50),
FUN = fyp)
SinActuar<-sapply(X = c(0,10,20,30,40,45,50),
FUN = aux)
conActuar<-sapply(X = c(0,10,20,30,40,45,50),
FUN = fyp)
M<-rbind(SinActuar,conActuar)
colnames(M)<-c(0,10,20,30,40,45,50)
M
set.seed(21)
#Monto del siniestro:
X<-runif(1000000,100,200)
#Costo por pérdida
YL<-pmax(alpha*(pmin(X*(1+r),u)-d),0)
X
#Costo por pérdida
YL<-pmax(alpha*(pmin(X*(1+r),u)-d),0)
YL[998]
YL>0
MASS::truehist(YL)
MASS::truehist(Yp)
#Costo por pago
Yp<-YL[YL>0]
MASS::truehist(Yp)
#Esperanza
mean(YL)
mean(Yp)
#Segundo momento
mean(YL^2)
mean(Yp^2)
var(Yp)
#Varianza
var(YL)
#Esperanza del coseno de ellas
mean(cos(YL))
mean(cos(Yp))
quantile(Yp,probs = 0.5)
#Cuantil del 50% (la mediana)
quantile(YL,probs = 0.5)
#Cuantil del 90%
quantile(YL,probs = 0.9)
quantile(Yp,probs = 0.9)
#Vamos a ver todo gráficamente
library(MASS)
#Costo por pérdida
truehist(YL, main="Costo por pérdida",col="skyblue")
plot(fyL,from = 0, to = 45,
add=T,col="red",lwd=2)
#Costo por pago
truehist(Yp,main="Costo por pago",col="skyblue")
plot(fyp,from = 0, to = 45,
add=T,col="red",lwd=2)
#Costo por pérdida
fyL(45)
sum(YL==45)/length(YL)
#Costo por pago
fyp(45)
sum(Yp==45)/length(Yp)
#Costo por pérdida
fyL(45)
sum(YL==45)/length(YL)
source("~/Actuaría/GitHub/R_Actuarial/_Edgar Package_/mis_funciones.R")
n=10
lower=c(0,6,1)
upper=c(1,9,28)
mapply(FUN = runif,
# Argumentos a vectorizar
min = lower,
max = upper,
# Argumentos fijos
MoreArgs = list(n = n)
) -> U
U
# Maximizar la siguiente funión
f <- function(x){
10-(x+5)^2
}
which.max(c(1,2,5,3,2,0))
which.min(c(1,2,5,3,2,0))
optimize.MC <- function(f,n,lower,upper,maximizar=FALSE){
# f := Función a optimizar (recibe vector y arroja un real)
# n := Número de simulaciones a realizar
# lower y upper := vectores, estos comprenden la región de búsqueda.
# maximizar := ¿Se quiere maximizar la función?
# Esto genera muchos vectores uniformes en la región de interés
mapply(FUN = runif,
# Argumentos a vectorizar
min = lower,
max = upper,
# Argumentos fijos
MoreArgs = list(n = n)
) -> U
# Vamos a aplicar la función a las Uniformes
apply(U,
# Por renglones
MARGIN = 1,
# Aplicamos la función
FUN = f) -> fU
if(maximizar){
indice <- which.max(fU)
return(list(max=U[indice,],
objetivo=fU[indice]))
}else{
indice <- which.min(fU)
return(list(min=U[indice,],
objetivo=fU[indice]))
}
}
f <- function(x){
10-(x+5)^2
}
a = -10 ; b = 10
# Gráfico
{
curve(f,from=a,to=b)
fondo_plot()
curve(f,from=a,to=b,add=TRUE,lwd=2)
abline(h=0,v=0,col="red",lwd=2)
}
# Con esto maximizamos
optim(par = 2,                 # Valor inicial
fn = f,               # Función a Optimizar
control=list(fnscale=-1), # Indicamos que queremos maximizar
# Con esto optimizamos con base en un intervalo
method = "Brent",
# Aquí es donde corre el intervalo
lower = a,
upper = b
)
optimize(
f = f, # Función a optimizar
interval = c(a,b),
maximum = TRUE
) -> optim.num
optim.num
abline(v = optim.num[[1]],
h = optim.num[[2]],
col="blue",lty=2)
# Como se hace en la versión MC
set.seed(6)
optim.MC <- optimize.MC(f = f,n = 1000,lower = a,upper = b,maximizar = TRUE)
optim.MC
abline(v = optim.MC[[1]],
h = optim.MC[[2]],
col="green",lty=2)
# Maximizar la siguiente funión
f <- function(x){
(cos(50*x) + sin(20*x))^2
}
# Región donde optimizaremos:
a = 0 ; b = 1
# Gráfico
{
curve(f,from=a,to=b)
fondo_plot()
curve(f,from=a,to=b,add=TRUE,lwd=2)
abline(h=0,v=0,col="red",lwd=2)
}
# Con esto maximizamos
optim(par = 2,                  # Valor inicial
fn = f,                   # Función a Optimizar
control=list(fnscale=-1), # Indicamos que queremos maximizar
# Con esto optimizamos con base en un intervalo
method = "Brent",
# Aquí es donde corre el intervalo
lower = a,
upper = b
)
optimize(
f = f, # Función a optimizar
interval = c(a,b),
maximum = TRUE
) -> optim.num
abline(v = optim.num[[1]],
h = optim.num[[2]],
col="blue",lty=2)
optim.num
# Como se hace en la versión MC
set.seed(6)
optim.MC <- optimize.MC(f = f,n = 1000,lower = a,upper = b,maximizar = TRUE)
abline(v = optim.MC[[1]],
h = optim.MC[[2]],
col="green",lty=2)
optim.MC
optim.num
set.seed(7)
optim.MC <- optimize.MC(f = f,n = 1000,lower = a,upper = b,maximizar = TRUE)
abline(v = optim.MC[[1]],
h = optim.MC[[2]],
col="green",lty=2)

{
cat("\014")
nombre = readline(prompt="Escribe tu nombre: ")
cat("\014")
}
{
cat("\014")
nombre = readline(prompt="Escribe tu nombre: ")
}
{
cat("\014")
nombre = readline(prompt="Escribe tu nombre: ")
cat("Hola",nombre)
}
{
cat("\014")
nombre = readline(prompt="Escribe tu nombre: ")
edad = readline(prompt="Escribe tu edad: ")
cat("Hola",nombre,"tienes",edad)
}
{
cat("\014")
nombre = readline(prompt="Escribe tu nombre: ")
edad = readline(prompt="Escribe tu edad: ")
cat("Hola",nombre,"tienes",edad)
}
{
cat("\014")
nombre = readline(prompt="Escribe tu nombre: ")
edad = readline(prompt="Escribe tu edad: ")
cat("Hola",nombre,"tienes",edad)
}
{
cat("\014") # Limpiamos la consola
nombre = readline(prompt="Escribe tu nombre: ")
edad = readline(prompt="Escribe tu edad: ")
cat("Hola",nombre,"tienes",edad)
}
n = 5 ; m = 5
n = 5 ; m = 3
1:(n*m)
M <- matrix(data = 1:(n*m),nrow = n,ncol = m)
M <- matrix(data = 1:(n*m), # El vector que vamos a hacer matriz
nrow = n,       # El número de renglones
ncol = m)       # El número de columnas
M
?matrix
M <- matrix(data = 1:(n*m), # El vector que vamos a hacer matriz
byrow = TRUE,   # Con esto estamos indicando llena por renglones
nrow = n,       # El número de renglones
ncol = m)       # El número de columnas
M # La matriz la fue llenando por columnas
class(M)
dim(M)
# Ejemplo Tania: Llenar la matriz con números particulares
I3 <- matrix(data = c(1,0,0,
0,1,0,
0,0,1),
byrow = TRUE,
nrow = 3)
I3
# Ejemplo Tania: Llenar la matriz con números particulares
I3 <- matrix(data = c(1,0,0,
0,1,0,
0,0,1),
byrow = TRUE,
nrow = 3)
I3
M
y <- M[4,3]
y
M[2,1]
M
M
M[4,2]
M[4,2] <- 100
M
# 3. Extraer renglones de una matriz
M
M[1,]
M[,3]
M[4,]
v <- M[4,]
v[2]
v[1]
v[c(1,2)]
v <- M[4, ]
v
M
M[2,1]
M[2,2]
M[3,1]
M[3,2]
matrix(c(M[2,1],M[2,2],M[3,1],M[3,2]),nrow = 2)
M
matrix(c(M[2,1],M[2,2],M[3,1],M[3,2]),nrow = 2)
matrix(c(M[2,1],M[2,2],M[3,1],M[3,2]),nrow = 2,byrow = TRUE)
M
c(2,3)
4,2
M
1:2
c(2,3)
M[c(2,3),1:2]
# Versión MUY MUY A Patita
matrix(c(M[2,1],M[2,2],M[3,1],M[3,2]),nrow = 2,byrow = TRUE)
M
M[c(TRUE,FALSE),]
R <- M[c(TRUE,FALSE),]
dim(R)
R[2,3]
M
M[4,]
M
M[4,]
v <- M[4,]
v
dim(v)
v <- M[4,]
v
v[c(1,2)]
v[c(1,2),]
v[c(1,2)]
v <- M[4,]
v
M
mat <- M[c(2,3),1:2]
dim(mat)
mat
M
(aux <- M[4,c(1,3)])
dim(aux)
aux
aux[2]
aux[2,]
aux[2]
M
(aux <- M[c(1:2,5),2])
aux[3]
aux[2]
M
t(M)
aux
t(aux)
aux
t(aux)
t(t(aux))
t(aux)
t(t(aux))
loquesea <- t(t(aux))
loquesea[2,1]
loquesea[2,]
M
M
t(M)
(aux <- t(M)[c(1,3),c(1,5)])
(aux <- t(M)[c(1,3),c(T,T,F)])
aux
t(M)
tM <- t(M)
tM <- t(M)
(aux <- tM[c(1,3),c(T,T,F)])
aux
(tM <- t(M))
(aux <- tM[c(1,3),c(T,T,F)])
(tM <- t(M))
(aux <- tM[c(1,3),c(T,T,F)])
(aux <- tM[-2,c(T,T,F)])
(aux <- tM[-2,-3])
m ; n
k = 2
l = 7
m ; n
k = 2
l = 4
n
m
1:(n*m*k*l)
A <- array(data = 1:(n*m*k*l),dim = c(n,m,k,l))
A
n
A
Cubo <- A[,,,1]
Cubo
Cubo[2,2,]
class(A)
class(Cubo)
Cubo[2,2,1]
Cubo[1:2,2,1]
Cubo[1:2,1:2,1]
class(Cubo[1:2,1:2,1])
dim(A)
t(M)
mat
t(mat)
# Transponer una matriz
?t
?diag
diag(M)
)
M
diag(t(M))
diag(M)
diag(M)
diag(t(M))
diag(mat)
mat
diag(1:4)
diag(mat)
diag(1:4)
M
A <- M[1:3,]
A
tail(M)
tail(M,3)
B <- tail(M,3)
B
B[1,1]
B[3,1]
B <- M[3:5,]
A <- M[1:3,]
B <- M[3:5,]  #tail(M,3)
A
B
A + B
A - B
A
B
A - B
A
B
A * B
I3
A * I3
A
A %*% B # Multiplicación de matrices
A
B
A %*% B # Multiplicación de matrices
sum(A[1,]*B[,1])
A[1,]*B[,1]
sum(A[1,]*B[,1])
A %*% B
sum(A[2,]*B[,3])
M
M
M
B %*% A
A %*% B # Multiplicación de matrices
dim(M)
M
A
dim(M)
dim(A)
M%*%A
dim(M)
dim(A)
A%*%M
A%*%I3
A
A*I3
A%*%I3
v <- (1:3)*10
v
v*A
A
v*A
v%*%A
v
A%*%v
exp(A)
A/B
A
B
A/B
A%/%B
?%/%
1%/%3
3%/%1
3%/%2
5%/%2
B%/%A
B
A
det(A)
det(B)
det(A)
det(A)
A
det(A)
det(B)
det(M)
A^-1
A
A^-1
1/A
solve(A)
det(A)
det(B)
solve(B)
InvB <- solve(B)
5 * (1/5)
1/7 * (7)
B%*%InvB
round(B%*%InvB,0)
B%*%InvB
round(B%*%InvB,0)
B%*%InvB
B
B[2,2] <- 11
B
solve(B)
det(B)
B[2,2] <- 100
solve(B)
B
1/0
round(B%*%InvB,0)
B%*%InvB
InvB%*%B
round(InvB%*%B)
# C = matriz de coeficientes
C <- matrix(C(1,1,
4,2),byrow = TRUE,2)
# C = matriz de coeficientes
C <- matrix(C(1,1,
4,2),byrow = TRUE,nrow = 2)
# C = matriz de coeficientes
C <- matrix(c(1,1,
4,2),byrow = TRUE,nrow = 2)
C
b <- c(540,1442)
C <- matrix(c(1,1,
4,2),byrow = TRUE,nrow = 2)
C
colnames(C) <- c("Vacas","Pollos")
C
rownames(C) <- c("Cabezas","Patas")
C
C["Vacas","Patas"]
C["Patas","Vacas"]
C[2,1]
C
names(b) <- c("Cabezas","Patas")
b
v = solve(C)%*%b
v
v = solve(C,b)
v
v["Vacas"] + v["Pollos"]
4*v["Vacas"] + 2*v["Pollos"] # Patas
v
v["Vacas"] + v["Pollos"] # Cabezas
4*v["Vacas"] + 2*v["Pollos"] # Patas
solve(C)%*%b
solve(C,b)
v = solve(C)%*%b
v
v["Vacas"] + v["Pollos"] # Cabezas
v
v["Vacas",]
v["Vacas",] + v["Pollos",] # Cabezas
solve(C)%*%b
v = solve(C)%*%b
v
# Opción automatizada
v = solve(C,b)
v
v = solve(C)%*%b
v
v
as.vector(v)
v <- as.vector(v)
# Opción a pata
v = solve(C)%*%b
v <- as.vector(v)
v
# Opción a pata
v = solve(C)%*%b
v
v <- v[,1]
v
v[,1]
# Opción a pata
v = solve(C)%*%b
v[,1]
v = solve(C)%*%b
v <- v[,1]
v
# Opción a pata
v = solve(C)%*%b
v <- v[,1]
v
# Opción automatizada
v = solve(C,b)
v
v["Vacas"] + v["Pollos"] # Cabezas
4*v["Vacas"] + 2*v["Pollos"] # Patas
# Opción automatizada
?solve
dnbinom(2:4,2,0.2)
dnbinom(2:5,2,0.2)
p = 0.2
a = 1-0.2
a = 0.8
b = 0.8
k = 2
a+b/(k+1)
0.08192/0.0768
a+b/(k+1)
0.08192/0.0768
a+b/(k+2)
0.08192/0.08192
0.078432/0.08192
a+b/(k+3)
dnbinom(5,2,0.2)/dnbinom(4,2,0.2)
0.078432/0.08192
dnbinom(5,2,0.2)
dnbinom(4,2,0.2)
dnbinom(5,2,0.2)
digits(10)
dnbinom(5,2,0.2)
dnbinom(4,2,0.2)
digits(100)
dnbinom(5,2,0.2)
dnbinom(4,2,0.2)
sprintf("%.100f",dnbinom(5,2,0.2))
sprintf("%.100f",dnbinom(4,2,0.2))
0.078432/0.08199
0.078432/0.08199999
0.078432/0.083
dnbinom(2:5,2,0.2)
dnbinom(5,2,0.2)/dnbinom(4,2,0.2)
a+b/(k+3)
dnbinom(2:5,2,0.2)
0.078432/0.083
dnbinom(5,2,0.2)/dnbinom(4,2,0.2)
dnbinom(5,2,0.2)
0.0786432/0.083
dnbinom(4,2,0.2)
0.0786432/0.08192
0.0786432
0.08192
0.0786432/0.08192
a+b/(k+3)
0.0786432/0.08192
dnbinom(5,2,0.2)/dnbinom(4,2,0.2)
dnbinom(2:5,2,0.2)
dnbinom(2:5,2,0.2)
a = 0.8
b = 0.8
k = 2
a+b/(k+1)
0.08192/0.0768
a+b/(k+2)
0.08192/0.08192
a+b/(k+3)
0.0786432/0.08192
dnbinom(5,2,0.2)/dnbinom(4,2,0.2)
a+b/(k+1)
0.08192/0.0768
a+b/(k+2)
0.08192/0.08192
a+b/(k+3)
0.0786432/0.08192
dnbinom(4,2,0.2)/dnbinom(2,2,0.2)
0.08192/0.08192
dnbinom(4,2,0.2)/dnbinom(3,2,0.2)
a+b/(k+1)
0.08192/0.0768
dnbinom(3,2,0.2)/dnbinom(2,2,0.2)
a+b/(k+2)
0.08192/0.08192
dnbinom(4,2,0.2)/dnbinom(3,2,0.2)
a+b/(k+3)
0.0786432/0.08192
dnbinom(5,2,0.2)/dnbinom(4,2,0.2)
# Librerías
library(plotly)    # Para hacer los gráficos
library(dplyr)     # Manipulación de datos
library(readr)     # Lectura de archivos
library(neuralnet) # Para crear redes neuronales
library(keras)     # Motor para DNN (Deep Neural Network)
library(tidymodels)# Para manejo de modelos
library(tree)      # Árboles de decisión
library(rpart)
tidymodels_prefer()
# Librería Edgar
setwd("~/Actuaría/GitHub/R_Actuarial/_Edgar Package_")
source("mis_funciones.R",encoding = "UTF-8")
conflict_prefer("prune", "rpart")
rpart::prune
lang::last_error()
install.packages("rlang")
install.packages("rlang")
# Librerías
library(plotly)    # Para hacer los gráficos
library(dplyr)     # Manipulación de datos
library(readr)     # Lectura de archivos
library(neuralnet) # Para crear redes neuronales
library(keras)     # Motor para DNN (Deep Neural Network)
library(tidymodels)# Para manejo de modelos
library(tree)      # Árboles de decisión
library(rlang)
library(rpart)
tidymodels_prefer()
# Librería Edgar
setwd("~/Actuaría/GitHub/R_Actuarial/_Edgar Package_")
source("mis_funciones.R",encoding = "UTF-8")
rlang::last_error()
conflict_prefer("prune", "rpart")
conflicted::conflict_prefer("prune", "rpart")

# Objeto auxiliar
probas <- c(-1,cdf,2)
sop <- c(soporte[1],soporte,soporte[length(soporte)])
# Esta función regresa el valor en el soporte tal que
# su intervalo de probabilidad contiene a U.
izquierdos <- head(probas,length(probas)-1)
derechos   <- tail(probas,length(probas)-1)
izquierdos
derechos
# Objeto auxiliar
probas <- c(0,cdf,2)
sop <- c(soporte[1],soporte,soporte[length(soporte)])
# Esta función regresa el valor en el soporte tal que
# su intervalo de probabilidad contiene a U.
izquierdos <- head(probas,length(probas)-1)
izquierdos
derechos   <- tail(probas,length(probas)-1)
derechos
# Objeto auxiliar
probas <- c(0,cdf,Inf)
sop <- c(soporte,soporte[length(soporte)])
# Esta función regresa el valor en el soporte tal que
# su intervalo de probabilidad contiene a U.
izquierdos <- head(probas,length(probas)-1)
derechos   <- tail(probas,length(probas)-1)
resultado  <- ifelse(izquierdos <= u & u < derechos,
sop, NA)
Regresa_x <- function(u, soporte, cdf){
# Objeto auxiliar
probas <- c(0,cdf,Inf)
sop <- c(soporte,soporte[length(soporte)])
# Esta función regresa el valor en el soporte tal que
# su intervalo de probabilidad contiene a U.
izquierdos <- head(probas,length(probas)-1)
derechos   <- tail(probas,length(probas)-1)
resultado  <- ifelse(izquierdos <= u & u < derechos,
sop, NA)
# Regresamos donde no hay NA, debería ser un único caso
return(resultado[!is.na(resultado)])
}
Regresa_x(0.126,soporte,cdf)
names(resultado) <- NA
Regresa_x <- function(u, soporte, cdf){
# Objeto auxiliar
probas <- c(0,cdf,Inf)
sop <- c(soporte,soporte[length(soporte)])
# Esta función regresa el valor en el soporte tal que
# su intervalo de probabilidad contiene a U.
izquierdos <- head(probas,length(probas)-1)
derechos   <- tail(probas,length(probas)-1)
resultado  <- ifelse(izquierdos <= u & u < derechos,
sop, NA)
names(resultado) <- NA
# Regresamos donde no hay NA, debería ser un único caso
return(resultado[!is.na(resultado)])
}
Regresa_x(0.126,soporte,cdf)
Regresa_x <- function(u, soporte, cdf){
# Objeto auxiliar
probas <- c(0,cdf,Inf)
sop <- c(soporte,soporte[length(soporte)])
# Esta función regresa el valor en el soporte tal que
# su intervalo de probabilidad contiene a U.
izquierdos <- head(probas,length(probas)-1)
derechos   <- tail(probas,length(probas)-1)
resultado  <- ifelse(izquierdos <= u & u < derechos,
sop, NA)
names(resultado) <- NULL
# Regresamos donde no hay NA, debería ser un único caso
return(resultado[!is.na(resultado)])
}
Regresa_x(0.126,soporte,cdf)
Regresa_x <- function(u, soporte, cdf){
# Objeto auxiliar
probas <- c(0,cdf,Inf)
sop <- c(soporte,soporte[length(soporte)])
# Esta función regresa el valor en el soporte tal que
# su intervalo de probabilidad contiene a U.
izquierdos <- head(probas,length(probas)-1)
derechos   <- tail(probas,length(probas)-1)
resultado  <- ifelse(izquierdos <= u & u < derechos,
sop, NA)
# Para no confundirnos
names(resultado) <- NULL
# Regresamos donde no hay NA, debería ser un único caso
return(resultado[!is.na(resultado)])
}
Regresa_x(0.126,soporte,cdf)
cdf
Regresa_x(0,soporte,cdf)
Regresa_x(0.875,soporte,cdf)
size = 3
prob = 0.5
cdf <- pbinom(0:size,size,prob)
soporte <- 0:size
# Objeto auxiliar
probas <- c(0,cdf,Inf)
sop <- c(soporte,soporte[length(soporte)])
sop
# Esta función regresa el valor en el soporte tal que
# su intervalo de probabilidad contiene a U.
izquierdos <- head(probas,length(probas)-1)
derechos   <- tail(probas,length(probas)-1)
izquierdos
derechos
probas <- c(0,cdf,Inf)
sop <- c(soporte,soporte[length(soporte)])
# Esta función regresa el valor en el soporte tal que
# su intervalo de probabilidad contiene a U.
izquierdos <- head(probas,length(probas)-1)
derechos   <- tail(probas,length(probas)-1)
izquierdos
derechos
size = 3
prob = 0.5
cdf <- pbinom(0:size,size,prob)
soporte <- 0:size
names(cdf) <- soporte
Regresa_x <- function(u, soporte, cdf){
# Objeto auxiliar
probas <- c(0,cdf,Inf)
sop <- c(soporte,soporte[length(soporte)])
# Esta función regresa el valor en el soporte tal que
# su intervalo de probabilidad contiene a U.
izquierdos <- head(probas,length(probas)-1)
derechos   <- tail(probas,length(probas)-1)
resultado  <- ifelse(izquierdos < u & u <= derechos,
sop, NA)
# Para no confundirnos
names(resultado) <- NULL
# Regresamos donde no hay NA, debería ser un único caso
return(resultado[!is.na(resultado)])
}
Regresa_x(0.875,soporte,cdf)
cdf
Regresa_x(0.876,soporte,cdf)
Regresa_x(1,soporte,cdf)
Regresa_x(0,soporte,cdf)
cdf
Regresa_x(0.1,soporte,cdf)
cdf
u=0
# Objeto auxiliar
probas <- c(0,cdf,Inf)
sop <- c(soporte,soporte[length(soporte)])
# Esta función regresa el valor en el soporte tal que
# su intervalo de probabilidad contiene a U.
izquierdos <- head(probas,length(probas)-1)
derechos   <- tail(probas,length(probas)-1)
resultado  <- ifelse(izquierdos < u & u <= derechos,
sop, NA)
resultado
Regresa_x <- function(u, soporte, cdf){
# Objeto auxiliar
probas <- c(-Inf,cdf,Inf)
sop <- c(soporte,soporte[length(soporte)])
# Esta función regresa el valor en el soporte tal que
# su intervalo de probabilidad contiene a U.
izquierdos <- head(probas,length(probas)-1)
derechos   <- tail(probas,length(probas)-1)
resultado  <- ifelse(izquierdos < u & u <= derechos,
sop, NA)
# Para no confundirnos
names(resultado) <- NULL
# Regresamos donde no hay NA, debería ser un único caso
return(resultado[!is.na(resultado)])
}
Regresa_x(0.1,soporte,cdf)
Regresa_x(0,soporte,cdf)
cdf
Regresa_x(0.125,soporte,cdf)
Regresa_x(0.126,soporte,cdf)
Regresa_x(0.5,soporte,cdf)
cdf
Regresa_x(0.51,soporte,cdf)
Regresa_x(1,soporte,cdf)
Regresa_x(0.9,soporte,cdf)
cdf
plot(cdf~soporte)
plot(cdf~soporte,type="s")
plot(cdf~soporte,type="s",ylim=c(0,1))
size = 3
prob = 0.5
cdf <- pbinom(0:size,size,prob)
soporte <- 0:size
names(cdf) <- soporte
# https://en.wikipedia.org/wiki/Quantile_function
plot(cdf~soporte,type="s",ylim=c(0,1)) # Inversa generalizada
Regresa_x <- function(u, soporte, cdf){
# Objeto auxiliar
probas <- c(-Inf,cdf,Inf)
sop <- c(soporte,soporte[length(soporte)])
# Esta función regresa el valor en el soporte tal que
# su intervalo de probabilidad contiene a U.
izquierdos <- head(probas,length(probas)-1)
derechos   <- tail(probas,length(probas)-1)
resultado  <- ifelse(izquierdos < u & u <= derechos,
sop, NA)
# Para no confundirnos
names(resultado) <- NULL
# Regresamos donde no hay NA, debería ser un único caso
return(resultado[!is.na(resultado)])
}
Regresa_x(0.9,soporte,cdf)
cdf
set.seed(6)
U <- runif(10000)
X <- sapply(U,Regresa_x,soporte,cdf)
# Gráfico
X %>% table() %>% barplot()
# Bondad de Ajuste
chisq.test(x = table(X), # Observadas
p = sapply(0:10,dbinom,size=10,prob=0.5)) # Esperadas
# Bondad de Ajuste
chisq.test(x = table(X), # Observadas
p = sapply(0:10,dbinom,size,prob)) # Esperadas
# Bondad de Ajuste
chisq.test(x = table(X), # Observadas
p = sapply(0:size,dbinom,size,prob)) # Esperadas
# Gráfico
X %>% prop.table() %>% barplot()
# Gráfico
X %>% table() %>% barplot()
# Bondad de Ajuste
chisq.test(x = table(X), # Observadas
p = sapply(0:size,dbinom,size,prob)) # Esperadas
# Parámetros
size = 3
prob = 0.5
Fx <- function(x){
pbinom(x,size,prob)
}
Regresa_x_Fx(0.5,Fx)
aux <- sapply(0:size,Fx)
# Parámetros
size = 3
prob = 0.5
Fx <- function(x){
pbinom(x,size,prob)
}
Regresa_x_Fx <- function(u,Fx,x_ini=0,step=1){
# Esta función regresa la x mínima tal que Fx(x)>u.
# Para esto, se asume que el soporte tiene una separación
# regular dada por una constante.
x = x_ini
while(Fx(x)<=u){
x <- x + step
}
return(x)
}
Regresa_x_Fx(0.5,Fx)
aux <- sapply(0:size,Fx)
names(aux) <- 0:size
aux # El 5 es el que acumula esa probabilidad
set.seed(6)
U <- runif(10000)
X <- sapply(U,Regresa_x_Fx,Fx)
# Gráfico
X %>% table() %>% barplot()
# Bondad de Ajuste
chisq.test(x = table(X), # Observadas
p = sapply(0:size,dbinom,size,prob)) # Esperadas
# Parámetros
size = 3
prob = 0.5
set.seed(6)
U <- runif(10000)
X <- sapply(U,qbimom,size,prob)
# Parámetros
size = 3
prob = 0.5
set.seed(6)
U <- runif(10000)
X <- sapply(U,qbinom,size,prob)
# Gráfico
X %>% table() %>% barplot()
# Bondad de Ajuste
chisq.test(x = table(X), # Observadas
p = sapply(0:size,dbinom,size,prob)) # Esperadas
# Parámetros
size = 3
prob = 0.5
set.seed(6)
U <- runif(10000)
X <- sapply(U,qbinom,size,prob)
# Gráfico
X %>% table() %>% barplot()
# Bondad de Ajuste
chisq.test(x = table(X), # Observadas
p = sapply(0:size,dbinom,size,prob)) # Esperadas
## Construimos la distribución mezcla:
Mezcla <- UnivarMixingDistribution(Norm(mean=-10, sd=3),
Norm(mean=10, sd=0.5),
Norm(),
mixCoeff=c(0.5, 0.3, 0.2))
library(distr)
## Construimos la distribución mezcla:
Mezcla <- UnivarMixingDistribution(Norm(mean=-10, sd=3),
Norm(mean=10, sd=0.5),
Norm(),
mixCoeff=c(0.5, 0.3, 0.2))
## Esto nos crea una función que simule del comportamiento de los datos que tendremos
rMezcla <- r(Mezcla)
## Ahora podemos simular de nuestra muestra personalizada.
set.seed(24)
# La función es costosa numéricamente, asi que con cuidado.
n = 5000
datos <- rMezcla(n = n)
## Hagamos un histograma:
MASS::truehist(datos,col=rainbow(50))
## Incluso podemos pegarle su función de densidad:
dMezcla <- d(Mezcla)
curve(dMezcla(x),from=-20,to=15,
lwd = 2, col="darkgreen",
add = TRUE)
## También podemos usar los datos para encontrar una densidad aproximada:
MASS::truehist(datos,col=rainbow(50))
lines(density(datos),col="darkblue",lwd=2)
## Función de distribución Empírica Vs. Teórica
pMezcla <- p(Mezcla)
plot(ecdf(datos),col="red")
curve(pMezcla(x),from=-30,to=20,add=TRUE,col="blue")
# Haciendo Bondad de Ajuste
ks.test(datos,pMezcla)
goftest::ad.test(datos,pMezcla)
## Con esto podemos hacer una estimación de los parámetros:
library(mixR)
fit2 <- mixfit(datos, ncomp = 2, family = "normal")
fit2 ; plot(fit2)
fit3 <- mixfit(datos, ncomp = 3, family = "normal")
fit3 ; plot(fit3)
fit4 <- mixfit(datos, ncomp = 4, family = "normal")
fit4 ; plot(fit4)
# Este es el ganador
fit3
## Estas son las puntuaciones de cada individuo:
View(fit3$comp.prob)
## Esto nos dice dónde es más factible que provenga cada individuo
library(magrittr)
Grupos<-apply(fit3$comp.prob,1,which.max) %>% as.factor()
# ¿Cuántos miembros hay en cada grupo.
table(Grupos)
## Podemos hacer un gráfico de cajas por clasificación:
boxplot(datos~clasific)
datos
clasific
## Podemos hacer un gráfico de cajas por clasificación:
boxplot(datos~Grupos)
lattice::histogram(~ datos | Grupos)
## Para finalmente guardarlo en un mismo lugar.
df<-data.frame(datos,Grupo=Grupos)
View(df)
library(distr)
## Construimos la distribución mezcla:
Mezcla <- UnivarMixingDistribution(Norm(mean=-10, sd=3),
Norm(mean=10, sd=0.5),
Norm(),
mixCoeff=c(0.5, 0.3, 0.2))
## Esto nos crea una función que simule del comportamiento de los datos que tendremos
rMezcla <- r(Mezcla)
## Ahora podemos simular de nuestra muestra personalizada.
set.seed(24)
# La función es costosa numéricamente, asi que con cuidado.
n = 5000
datos <- rMezcla(n = n)
## Hagamos un histograma:
MASS::truehist(datos,col=rainbow(50))
## Incluso podemos pegarle su función de densidad:
dMezcla <- d(Mezcla)
curve(dMezcla(x),from=-20,to=15,
lwd = 2, col="darkgreen",
add = TRUE)
## También podemos usar los datos para encontrar una densidad aproximada:
MASS::truehist(datos,col=rainbow(50))
lines(density(datos),col="darkblue",lwd=2)
## Función de distribución Empírica Vs. Teórica
pMezcla <- p(Mezcla)
plot(ecdf(datos),col="red")
curve(pMezcla(x),from=-30,to=20,add=TRUE,col="blue")
# Haciendo Bondad de Ajuste
ks.test(datos,pMezcla)
goftest::ad.test(datos,pMezcla)
## Con esto podemos hacer una estimación de los parámetros:
library(mixR)
fit2 <- mixfit(datos, ncomp = 2, family = "normal")
fit2 ; plot(fit2)
fit3 <- mixfit(datos, ncomp = 3, family = "normal")
fit3 ; plot(fit3)
fit4 <- mixfit(datos, ncomp = 4, family = "normal")
fit4 ; plot(fit4)
# Este es el ganador
fit3
?rmultinom
num_grupos <- 4
# Pesos
coeficientes <- c(0.2,0.3,0.4,0.1)
rmultinom(1,
size = num_grupos,
prob = coeficientes)
rmultinom(1,
size = 1,
prob = coeficientes)
rmultinom(1,
size = 1,
prob = coeficientes)
rmultinom(1,
size = 1,
prob = coeficientes)
rmultinom(1,
size = 1,
prob = coeficientes)
rmultinom(1,
size = 1,
prob = coeficientes)
rmultinom(1,
size = 1,
prob = coeficientes)
rmultinom(1,
size = 1,
prob = coeficientes)
rmultinom(1,
size = 1,
prob = coeficientes)
rmultinom(1,
size = 1,
prob = coeficientes)
rmultinom(1,
size = 1,
prob = coeficientes)
rmultinom(1,
size = 1,
prob = coeficientes)
rmultinom(1,
size = 1,
prob = coeficientes)
rmultinom(1,
size = 1,
prob = coeficientes)
# Esta puede pensarse como una indicadora vectorial
rmultinom(1,
size = 1,
prob = coeficientes)
# Tamaño de muestra de la mezcla:
n = 1
# Pesos
coeficientes <- c(0.2,0.3,0.4,0.1)
# Esta puede pensarse como una indicadora vectorial
rmultinom(1,
size = 1,
prob = coeficientes)
# Con esto podemos crear una matriz de simulaciones de cada mezcla
Mat_sim <- matrix(data = c(rnorm(n),
rnorm(n,-5,2),
rnorm(n,5,4),
rnorm(n,10,0.25)),
byrow = TRUE,nrow = 4)
Mat_sim
rmultinom==1
# Esta puede pensarse como una indicadora vectorial
rmultinom(n,
size = 1,
prob = coeficientes) -> indicadora
indicadora==1
Mat_sim[indicadora==1]
# Nos quedamos únicamente donde la indicadora nos quizo dar el resultado.
Mat_sim[indicadora==1]
# Tamaño de muestra de la mezcla:
n = 100000
# Pesos
coeficientes <- c(0.2,0.3,0.4,0.1)
# Esta puede pensarse como una indicadora vectorial
rmultinom(n,
size = 1,
prob = coeficientes) -> indicadora
# Con esto podemos crear una matriz de simulaciones de cada mezcla
Mat_sim <- matrix(data = c(rnorm(n),
rnorm(n,-5,2),
rnorm(n,5,4),
rnorm(n,10,0.25)),
byrow = TRUE,nrow = 4)
Mat_sim
# Aumentemos el tamaño de muestra
set.seed(1234)
# Tamaño de muestra de la mezcla:
n = 100000
# Pesos
coeficientes <- c(0.2,0.3,0.4,0.1)
# Esta puede pensarse como una indicadora vectorial
rmultinom(n,
size = 1,
prob = coeficientes) -> indicadora
# Con esto podemos crear una matriz de simulaciones de cada mezcla
Mat_sim <- matrix(data = c(rnorm(n),
rnorm(n,-5,2),
rnorm(n,5,4),
rnorm(n,10,0.25)),
byrow = TRUE,nrow = 4)
# Nos quedamos únicamente donde la indicadora nos quizo dar el resultado.
Mat_sim[indicadora==1]
# Esta es una uestra de tamaño 'n' de la mezcla.
MASS::truehist(Mat_sim[indicadora==1])
# Esta es una uestra de tamaño 'n' de la mezcla.
MASS::truehist(Mat_sim[indicadora==1],xlab="x")
setwd("~/Actuaría/Docencia/AMAT/R Aplicado/_ Clases/4. Análisis No Supervisado")
setwd("~/Actuaría/Docencia/AMAT/R Aplicado/_ Clases/4. Análisis No Supervisado")
dat <- read.table("Perspectiva.txt") %>% as.matrix()
library(rgl)
library(magrittr)
setwd("~/Actuaría/Docencia/AMAT/R Aplicado/_ Clases/4. Análisis No Supervisado")
dat <- read.table("Perspectiva.txt") %>% as.matrix()
setwd("~/Actuaría/Docencia/AMAT/R Aplicado/_ Clases/4. Análisis No Supervisado/Perspectiva")
dat <- read.table("Perspectiva.txt") %>% as.matrix()
